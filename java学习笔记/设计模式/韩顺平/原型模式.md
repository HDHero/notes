[Toc]





# 原型模式

引子：

现在有一只羊tom，姓名为：tom，年龄为1；颜色为：白色。请编写程序创建和tom属性完全相同的10只羊。



## 1.传统方式解决克隆羊

### 1.1 代码

```java
public class Sheep {

    private Integer age;

    private String name;

    private String color;

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public Sheep(Integer age, String name, String color) {
        this.age = age;
        this.name = name;
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", color='" + color + '\'' +
                '}';
    }
}
```

```java

public static void main(String args[]) {
    Sheep sheep = new Sheep(1,"Tom","white");
    Sheep s2 = new Sheep(sheep.getAge(),sheep.getName(),sheep.getColor());
}
```

### 1.2 优缺点

（1） 优点是比较好理解，简单易操作

### （1） 在创建新的对象时，总是需要获取原始对象的属性，如果创建的对象比较复杂时，效率较低

（2）总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活

### 1.3 改进思路：

java中的Object类是所有类的根类，Object类提供一个clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力--原型模式



## 2.原型模式

### 2.1 基本介绍

1）原型模式ProtoType是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建的对象

2）原型模式是一种创建型的设计模式，运行一个对象创建另外一个可定制的对象，无需知道如何创建的细节

3）工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()

![prototype](E:\笔记\java学习笔记\设计模式\韩顺平\pic\prototype.png)



原理结构图说明：

1) ProtoType:原型类：声明一个克隆自己的接口

2）ConcretePrototype：具体的原型类，实现一个克隆自己的操作

3）client：让一个原型对象克隆自己，从而创建一个克隆对象



### 2.2 代码

```java
public class sheep implements Cloneable {
  //克隆该实例，使用默认的clone方法完成
  @Override
  protected Object clone()  {
      try{
		Sheep sheep = null;  
      	sheep = (Sheep)supper.clone();
	    return sheep;

    }
    catch (CloneNotSupportedException e ) {
        sout("异常");
    }
}
```

注意：克隆出来的对象与原对象所指的地址不一样，但是属性是一样的

```java
public class Clinet {
    psvm(){
        Sheep sheep = new Sheep(1,"Tom","white");
        Sheep sheep2 = (Sheep)sheep.clone();
        Sheep sheep3 = (Sheep)sheep.clone();

    }
}
```



### 2.3 应用介绍Spring 框架中使用的原型模式

1 spring中原型bean的创建，就是原型模式的应用

```java
@SpringBootApplication
public class Prototype {

    public static void main(String[] args) {
        SpringApplication.run(Prototype.class, args);
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(Prototype.class);

        Object bean = applicationContext.getBean("remousServicce");

        System.out.println("bean " + bean);


    }
}
```

```java

@Component("remousServicce")
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class TestService {


    public void testFun() {
        System.out.println("this is my testFun");
    }
}
```



## 3 深拷贝和浅拷贝

### 3.1 浅拷贝的介绍

3.1.1 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将属性值一份给新的对象

3.1.2 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。实际上两个对象的成员变量都指向同一个实例，在这种情况下，在一个对象中修改该成员变量会影响到另一个对象成员变量。

3.1.3 浅拷贝是使用默认的clone()方法来实现。



### 3.2 深拷贝的介绍

(1) 复制对象的所有基本数据类型的成员变量值

(2) 为所有引用数据类型的成员变量申请储存空间，对象进行深拷贝要对整个对象进行拷贝

(3) 深拷贝实现方式1：重写clone方法来实现深拷贝

(4) 深拷贝实现方式2：通过对象序列化 实现深拷贝 （Serializable，Cloneable）



#### 3.1.1 深拷贝案例

1 第一种方式

```java
public class DeepClone implements Serializable, Cloneable {

    private String deepCloneName ;

    private DeepTarge deepTarge;

    public DeepClone() {
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        //1.先克隆基本数据类型
        Object obj = null;

        obj = super.clone();

        //2.再克隆引用类型

        DeepClone deepClone = (DeepClone)obj;

        deepClone.deepTarge = (DeepTarge) deepTarge.clone();

        return deepClone;
    }
}
```

```java
        //client
        DeepClone deepClone = new DeepClone();

        deepClone.setDeepCloneName("cloneName");

        DeepTarge deepTarge = new DeepTarge("targeDeep1","1001");

        deepClone.setDeepTarge(deepTarge);

        DeepClone clone = (DeepClone) deepClone.clone();

        System.out.println("p1.name=" + deepClone.getDeepCloneName() + " ||hasCode=" + deepTarge.hashCode());

        System.out.println("clone.name=" + clone.getDeepCloneName() + " ||hasCode=" + clone.hashCode());
```



弊端：如果引用类型有多个的话，则代码就很臃肿



2 深拷贝方式2

//通过对象的序列化实现



```java

    /**
     * 输出为字节流，再读回来，即完成了深拷贝
     * @return
     */
    public Object getCloneObj() {

        //字节流输出对象
        ByteArrayOutputStream bos = null;

        //对象输出流
        ObjectOutputStream oos = null;

        //字节流输入流
        ByteArrayInputStream bis = null;

        //对象输入流
        ObjectInputStream ois = null;

        try {
            //序列化就是指把Java对象转换为字节序列的过程

            bos = new ByteArrayOutputStream();

            oos = new ObjectOutputStream(bos);

            //将当前对象以对象流的方式输出
            oos.writeObject(this);

            //反序列化就是指把字节序列恢复为Java对象的过程。

            bis = new ByteArrayInputStream(bos.toByteArray());

            ois = new ObjectInputStream(bis);

            DeepClone deepClone = (DeepClone) ois.readObject();

            return deepClone;


        } catch (Exception e) {

            e.printStackTrace();

            return null;
        } finally {
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (Exception e) {

                e.printStackTrace();
            }
        }
    }
```

