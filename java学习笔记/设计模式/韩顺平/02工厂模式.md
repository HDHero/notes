[Toc]





# 工厂模式

## 1 传统模式

### 1.1 需求

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

#### 1.1.1 披萨种类

 披萨的种类很多(比如 GreekPizz, ChineesePizz等)

#### 1.1.2 披萨的制作

披萨的制作有prepare、bake、cut、box

#### 1.1.3 披萨的订购

完成披萨店订购功能

### 1.2 实现

#### 1.2.1 类图

![pizzClass](E:\笔记\java学习笔记\设计模式\韩顺平\pic\pizzClass.png)

#### 1.2.2 代码

##### 1.2.2.1 披萨抽象类

```java
//将Pizza写成抽象类
public abstract class Pizza{
    
    protected String name;

    //准备原材料，不同的披萨不一样，因此，我们做出抽象方法
    public abstract void prepare();
    
    public void bake(){
        System.out.println(name+" baking....");
    }
    public void cut(){
        System.out.println(name+ " cuting...")；
    }
    public void box(){
        System.out.println(name+"boxing...");
    }
    public void setName(String name){
        this.name=name;
    }
}
```

##### 1.2.2.2具体的类--奶酪

```java
public class CheesePizza extends Pizza{
    @Override
    public void prepare(){
        setName("奶酪pizza");
        sout(name+"prepareing...");
    }
    
}
```

##### 1.2.2.3 具体的类--希腊披萨

```java
public class GreekPizza extends Pizza{
    @Override
    public void prepare(){
        setName("GreekPizza");
        sout(name+"preparing...")
    }
}
```

##### 1.2.2.4 订单的类

```java
public class OrderPizza{
    //构造器
    public OrderPizza(){
        Pizza pizz=null;
        String orderType; //订购披萨的类型
        do {
            orderType = getType;
            if(orderType.equals("greek")){
                pizza = new GreepPizza();
                pizza.setName("希腊披萨");
            }
            else if (orderType.equals("cheese")){
                pizza = new CheessePizza();
                pizza.setName("奶酪披萨");
            }
            else {
                break;
            }
            //输出pizza的制作过程
            pizza.prepare();
            pizza,bake();
            pizza.cut();
            pizza.box();
        }
        while(true);
    }
    
    //写一个方法，可以动态获取客户需要订购的种类
    private String getType(){
        try{
            BufferedReader strin = new BUfferedReader(new InputStream());
            sout("输入pizz种类");
            String str = strin.readLine();
            return str;
        }
        catch (IOException e){
            e.printStackTrace();
            return "";
        }
    }
}
```

##### 1.2.2.5 app

```java
main() {
	new OrderPizza();
}
```

### 1.3 传统的方式的优缺点

(1) 优点是比较好理解，简单易操作

(2) 缺点是违反了设计模式的<font color='red'>OCT原则，即对扩展开放，对修改关闭</font>，即当我们给类增加新功能的时候，尽量不修改代码。

(3) 比如我们这时要新增一个Pizz的种类(Cheese披萨),我们需要做修改

```java
//新增写
else if (orderType.eqauls("cheese")){
    pizza =  new CheesePizza();
    pizza = new CheesePizza();
}

```

### 1.4 改进的思路分析

#### 1.4.1 分析

修改代码是可以接受的，但是如果我们在其它的地方也有创建Pizza的代码，就意味着，也要修改，而创建Pizza的代码，往往有多处。

#### 1.4.2 思路

把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该类就可，<font color='red'>其它有创建到Pizza对象的代码就不需要修改了</font>。



## 1.2 简单工厂模式

### 1.2.1 介绍

简单工厂模式属于创建型模式，是工厂模式的一种。<font color='red'>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</font>

简单工厂模式：定义一个创建对象的类，由这个类来封装实例化对象的行为.

在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

简单工厂模式也叫静态工厂模式。

### 1.2.2 简单工厂类

```java
public class SimpleFactory{
	//根据orderType 返回对应的Pizzs 对象
    public Pizza createPizza (String orderType){
        Pizza pizza = null;
   		if(orderType.equals("greek")){
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        }     
        else if(orderType.equals("cheese")){
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        }
        return pizza;   
    }
}
```

```java
public class OrderPizza{
    //构造器
    public OrderPizza(SimpleFatory simpleFactory){
        setFactory(simpleFactory);
    }
    
    SimpleFactory simpleFactory;
    Pizza pizza = null;
    public void setFactory(SimpleFactory simpleFactory){
        String orderType = ""; //用户输入的
        
        this.simpleFactory = simpleFactory; //设置简单工厂模式
        do {
            orderType = getType();
            pizza = this.simpleFactory.createPizza(orderType);
            //输出pizza
            if(pizza != null){
                pizza.prepare();
                pizza.bake();
            }else {
                sout("订购失败，没有该披萨");
                break;
            }           
        }while(true);
    }
}

```

调用方式

```java
main(){
    new OrderPizza(new SimpleFactory());  //简单工厂模式
}
```

## 1.3 工厂方法模式

### 1.3.1 需求

披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如北京的奶酪pizza、北京的胡椒pizza或者是伦敦的奶酪pizza等。地理位置+口味

#### 1.3.1.2 思路1

使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory等等。从当前这个案例来说，考虑到项目规模，以及软件的可维护性、可扩展性并不是特别好。

#### 1.3.1.2 思路2

<font color='red'>使用工厂方法模式</font>



#### 1.3.1.3 工厂方法模式介绍

工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。

工厂方法模式：定义了一个创建对象的抽象方法，由子类决定实例化的类。工厂方法模式将对象的实例化推迟到子类。



### 1.3.2 代码

#### 1.3.2.1 类图

![pizzaSimpleFactory](E:\笔记\java学习笔记\设计模式\韩顺平\pic\pizzaSimpleFactory.png)

#### 1.3.2.2 实现

北京奶酪pizza

```java
public class BJCheessePizza extends Pizza{
    @Override
    public void prepare(){
        sout("北京的奶酪pizza，准备原材料");     
    }
}
```

北京胡椒pizza

```java
public class BJPeppperPizza extends Pizza{
    @Override
    public void prepare(){
        sout("北京的胡椒pizza，准备原材料");     
    }
}
```

伦敦奶酪pizza

```java
public class LDCheessePizza extends Pizza{
    @Override
    public void prepare(){
        sout("伦敦的奶酪pizza，准备原材料");     
    }
}
```

伦敦胡pizza

```java
public class LDPepppePizza extends Pizza{
    @Override
    public void prepare(){
        sout("伦敦的胡椒pizza，准备原材料");     
    }
}
```

**OrderPizza** --充当工厂的角色

```java
public abstract class OrderPizza{
    
    //定义一个抽象方法，createPizza，让各个工厂子类自己实现
    abstract Pizza createPizza(String orderType);
    
    //构造器
    public OrderPizza(){
        Pizza pizza = null;
        String orderType; //订购披萨的类型
        do {
            orderType = getType();
			pizza = createPizza(orderType);  //工厂子类实现
            //输出pizza
            if(pizza != null){
                pizza.prepare();
                pizza.bake();
            }while(true);                
    }
        
}
```



BJOrderPizza -充当工厂类的实现

```java
public class BJOrderPizza extends OrderPizza{

    @Override
    Pizza createPizza(String orderType){
    	Pizza pizza = null;
        if(orderType.equals("cheese")){
            pizza = new BJCheesePizza();
        }
        else if (orderType.equals("pepper")){
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
    
}
```

### 

LDOrderPizza

```java
public class LDOrderPizza extends OrderPizza{
        @Override
    Pizza createPizza(String orderType){
    	Pizza pizza = null;
        if(orderType.eauls("cheese")){
            pizza = new LDCheesePizza();
        }
        else if (orderType.eqauls("pepper")){
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}
```

```java
main(){
         //创建北京口味的pizza
        new BJOrderPizza();
}
```



### 1.3.3 抽象工厂模式

#### 1.3.3.1 介绍

1) 抽象工厂模式：定义了一个接口，用于创建相关或有依赖关系的对象簇，则无需指明具体的类

2) 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合

3) 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)

4) 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样讲单个的简单工厂类变成了工厂簇。更利于代码的维护和扩展。

![pizzaFactoryPlus](E:\笔记\java学习笔记\设计模式\韩顺平\pic\pizzaFactoryPlus.png)

#### 1.3.3.2 代码

```java
//一个抽象工厂模式的抽象层(接口)
public interface AbsFactory{
    //让工厂子类来具体实现。
    public Pizza createPizza(String orderType);
}
```

BJFactory

```java
public class BJFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType){
        Pizza pizza = null;
        if(orderType.eauls("cheese")){
         pizza = new BJCheesePizza();
       }
        else if (orderType.eqauls("pepper")){
            pizza = new BJPepperPizza();
        }
      return pizza;    
    }
}
```

LDFactory

```java
public class LDFactory implements OrderPizza{
        @Override
    Pizza createPizza(String orderType){
    	Pizza pizza = null;
        if(orderType.eauls("cheese")){
            pizza = new LDCheesePizza();
        }
        else if (orderType.eqauls("pepper")){
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}
```

OrderPizza

```java
public class OrderPizza{
    AbsFactory factory;
    
    //构造器
    public OrderPizza(AbsFactory facotry){
        setFactory(factory);
    }
    private void setFactory(AbsFactory factory){
        Pizza pizza = null;
        String orderType = ""; //用户输入
        this.factory = factory;
        
        do{
            orderType = getType();
            //factory 可能是北京的工厂子类，也可能是伦敦的工程子类
            pizza = factory.createPizza(orderType);
			if(pizza != null){ //订购成功
                pizza.prepare();
                pizza.bake();
            }else{
                sout("订购失败");
                break;
            }                         
        }while(true);
    }
}
```

main

```java
main(){
    new OrderPizza(new BJFactory());
}
```

## 1.4 JDK源码分析

工厂是在JDK-Calendar应用的源码分析

 JDK中的Calendar类中，就使用了简单工厂模式

```java
public class SimpleFactory{
    public static void main(String [] args){
        Calendar cal = Calendar.getInstance();
        //注意月份下标从0开始，所以取月份要+1
        sout("年 " + cal.get(Calendar.YEAR));
        sout("日 " + cal.get(Calendar.DAY_OF_MONTH));
    }
}
```

```java
public static Calendar getInstance(){
    return createCalendar(TimeZone.getDefault(),Locale.getDefault(Locale.Category.FORMAT));
}
```

```java
private static Calendar createCalendar(TimeZone,Local alocale){
        CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                                 .getCalendarProvider();
    if(provider != null){
        .....
    }
}
```



## 1.5 工厂模式小结

### 1.5.1 工厂模式的意义

将实例化对象的代码提前出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而替换项目的扩展性和维护性。

### 1.5.2 三种工厂模式

简单工厂模式（静态工厂模式）

抽象工厂模式

工厂方法模式

### 1.5.3 设计模式的依赖抽象原则

创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂方法中，并返回。有的书上说。变量不要直接持有具体类的引用。

不要让类继承具体类，而是继承抽象类或者事项interface

不要覆盖基类已经实现的方法。